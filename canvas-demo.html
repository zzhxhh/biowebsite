<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas绘图演示 - 全能导航</title>
    <link rel="stylesheet" href="css/styles.css">
    <style>
        .canvas-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .canvas-section {
            background: var(--surface-color);
            border: 3px solid var(--primary-color);
            border-radius: 20px;
            padding: 30px;
            margin: 20px 0;
            transform: rotate(-0.5deg);
            box-shadow: var(--shadow-medium);
        }
        
        .canvas-section:nth-child(even) {
            transform: rotate(0.5deg);
        }
        
        #drawingCanvas {
            border: 2px solid var(--primary-color);
            border-radius: 10px;
            cursor: crosshair;
            background: white;
            display: block;
            margin: 20px auto;
        }
        
        #staticCanvas {
            border: 2px solid var(--accent-color);
            border-radius: 10px;
            background: white;
            display: block;
            margin: 20px auto;
        }
        
        .canvas-controls {
            text-align: center;
            margin: 20px 0;
        }
        
        .canvas-btn {
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 15px;
            margin: 5px;
            cursor: pointer;
            font-weight: 600;
            transform: rotate(-1deg);
            transition: all 0.3s ease;
        }
        
        .canvas-btn:hover {
            transform: rotate(0deg) scale(1.05);
            background: var(--accent-color);
        }
        
        .color-picker {
            margin: 10px;
        }
        
        .color-option {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: inline-block;
            margin: 5px;
            cursor: pointer;
            border: 2px solid #333;
            transition: transform 0.2s ease;
        }
        
        .color-option:hover {
            transform: scale(1.2);
        }
        
        .color-option.active {
            border: 3px solid var(--primary-color);
            transform: scale(1.1);
        }
    </style>
</head>
<body>
    <!-- 导航栏 -->
    <nav class="navbar">
        <div class="nav-container">
            <div class="nav-logo">
                <span class="logo-icon">🤖</span>
                <span class="logo-text">网站导航</span>
            </div>
            <ul class="nav-menu">
                <li><a href="index.html">首页</a></li>
                <li><a href="favorites.html">收藏</a></li>
                <li><a href="about.html">关于我们</a></li>
                <li><a href="canvas-demo.html" class="active">Canvas演示</a></li>
            </ul>
            <div class="nav-actions">
                <button class="theme-toggle" id="themeToggle">
                    <i class="fas fa-moon"></i>
                </button>
            </div>
        </div>
    </nav>

    <div class="canvas-container">
        <h1 style="text-align: center; color: var(--primary-color); margin: 40px 0;">
            🎨 Canvas绘图演示
        </h1>

        <!-- 静态绘图演示 -->
        <div class="canvas-section">
            <h2>📊 静态图形绘制</h2>
            <p>使用Canvas API绘制的静态图形，包括几何图形、渐变效果和文字。</p>
            <canvas id="staticCanvas" width="600" height="400"></canvas>
            <div class="canvas-controls">
                <button class="canvas-btn" onclick="drawStaticGraphics()">重新绘制</button>
                <button class="canvas-btn" onclick="clearStaticCanvas()">清空画布</button>
            </div>
        </div>

        <!-- 交互式绘图 -->
        <div class="canvas-section">
            <h2>✏️ 交互式绘图板</h2>
            <p>点击并拖拽鼠标在画布上绘制，支持多种颜色和画笔大小。</p>
            
            <div class="canvas-controls">
                <div class="color-picker">
                    <span>选择颜色：</span>
                    <div class="color-option active" data-color="#ff6b6b" style="background: #ff6b6b;"></div>
                    <div class="color-option" data-color="#4ecdc4" style="background: #4ecdc4;"></div>
                    <div class="color-option" data-color="#45b7d1" style="background: #45b7d1;"></div>
                    <div class="color-option" data-color="#96ceb4" style="background: #96ceb4;"></div>
                    <div class="color-option" data-color="#feca57" style="background: #feca57;"></div>
                    <div class="color-option" data-color="#ff9ff3" style="background: #ff9ff3;"></div>
                    <div class="color-option" data-color="#54a0ff" style="background: #54a0ff;"></div>
                    <div class="color-option" data-color="#000000" style="background: #000000;"></div>
                </div>
                
                <div style="margin: 10px;">
                    <label>画笔大小：</label>
                    <input type="range" id="brushSize" min="1" max="20" value="5">
                    <span id="brushSizeDisplay">5px</span>
                </div>
            </div>
            
            <canvas id="drawingCanvas" width="600" height="400"></canvas>
            
            <div class="canvas-controls">
                <button class="canvas-btn" onclick="clearDrawingCanvas()">清空画布</button>
                <button class="canvas-btn" onclick="saveDrawing()">保存图片</button>
                <button class="canvas-btn" onclick="drawSamplePattern()">绘制示例</button>
            </div>
        </div>

        <!-- 动画演示 -->
        <div class="canvas-section">
            <h2>🌟 动画效果演示</h2>
            <p>Canvas动画效果，包括粒子系统和动态图形。</p>
            <canvas id="animationCanvas" width="600" height="300"></canvas>
            <div class="canvas-controls">
                <button class="canvas-btn" onclick="startAnimation()">开始动画</button>
                <button class="canvas-btn" onclick="stopAnimation()">停止动画</button>
                <button class="canvas-btn" onclick="resetAnimation()">重置</button>
            </div>
        </div>
    </div>

    <!-- JavaScript -->
    <script src="js/utils.js"></script>
    <script>
        // Canvas绘图功能
        class CanvasDemo {
            constructor() {
                this.initStaticCanvas();
                this.initDrawingCanvas();
                this.initAnimationCanvas();
                this.initColorPicker();
                this.initBrushSize();
            }

            // 初始化静态画布
            initStaticCanvas() {
                this.staticCanvas = document.getElementById('staticCanvas');
                this.staticCtx = this.staticCanvas.getContext('2d');
                this.drawStaticGraphics();
            }

            // 初始化绘图画布
            initDrawingCanvas() {
                this.drawingCanvas = document.getElementById('drawingCanvas');
                this.drawingCtx = this.drawingCanvas.getContext('2d');
                this.isDrawing = false;
                this.currentColor = '#ff6b6b';
                this.currentSize = 5;

                // 绑定鼠标事件
                this.drawingCanvas.addEventListener('mousedown', (e) => this.startDrawing(e));
                this.drawingCanvas.addEventListener('mousemove', (e) => this.draw(e));
                this.drawingCanvas.addEventListener('mouseup', () => this.stopDrawing());
                this.drawingCanvas.addEventListener('mouseout', () => this.stopDrawing());

                // 绑定触摸事件（移动端支持）
                this.drawingCanvas.addEventListener('touchstart', (e) => this.startDrawing(e.touches[0]));
                this.drawingCanvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    this.draw(e.touches[0]);
                });
                this.drawingCanvas.addEventListener('touchend', () => this.stopDrawing());
            }

            // 初始化动画画布
            initAnimationCanvas() {
                this.animationCanvas = document.getElementById('animationCanvas');
                this.animationCtx = this.animationCanvas.getContext('2d');
                this.particles = [];
                this.animationId = null;
                this.createParticles();
            }

            // 绘制静态图形
            drawStaticGraphics() {
                const ctx = this.staticCtx;
                const canvas = this.staticCanvas;
                
                // 清空画布
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // 绘制渐变背景
                const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                gradient.addColorStop(0, '#ff9a9e');
                gradient.addColorStop(1, '#fecfef');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // 绘制几何图形
                this.drawGeometricShapes(ctx);
                
                // 绘制文字
                this.drawText(ctx);
                
                // 绘制图表
                this.drawChart(ctx);
            }

            drawGeometricShapes(ctx) {
                // 绘制圆形
                ctx.beginPath();
                ctx.arc(150, 100, 50, 0, Math.PI * 2);
                ctx.fillStyle = '#4ecdc4';
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 3;
                ctx.stroke();

                // 绘制矩形
                ctx.fillStyle = '#ff6b6b';
                ctx.fillRect(250, 50, 100, 100);
                ctx.strokeRect(250, 50, 100, 100);

                // 绘制三角形
                ctx.beginPath();
                ctx.moveTo(450, 50);
                ctx.lineTo(400, 150);
                ctx.lineTo(500, 150);
                ctx.closePath();
                ctx.fillStyle = '#feca57';
                ctx.fill();
                ctx.stroke();

                // 绘制星形
                this.drawStar(ctx, 150, 250, 5, 40, 20);
            }

            drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
                let rot = Math.PI / 2 * 3;
                let x = cx;
                let y = cy;
                const step = Math.PI / spikes;

                ctx.beginPath();
                ctx.moveTo(cx, cy - outerRadius);

                for (let i = 0; i < spikes; i++) {
                    x = cx + Math.cos(rot) * outerRadius;
                    y = cy + Math.sin(rot) * outerRadius;
                    ctx.lineTo(x, y);
                    rot += step;

                    x = cx + Math.cos(rot) * innerRadius;
                    y = cy + Math.sin(rot) * innerRadius;
                    ctx.lineTo(x, y);
                    rot += step;
                }

                ctx.lineTo(cx, cy - outerRadius);
                ctx.closePath();
                ctx.fillStyle = '#96ceb4';
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.stroke();
            }

            drawText(ctx) {
                ctx.font = 'bold 24px Arial';
                ctx.fillStyle = '#333';
                ctx.textAlign = 'center';
                ctx.fillText('Canvas绘图演示', 300, 320);
                
                ctx.font = '16px Arial';
                ctx.fillStyle = '#666';
                ctx.fillText('HTML5 Canvas API 图形绘制', 300, 350);
            }

            drawChart(ctx) {
                // 简单的柱状图
                const data = [30, 50, 80, 40, 70];
                const barWidth = 40;
                const startX = 400;
                const startY = 300;

                data.forEach((value, index) => {
                    const x = startX + index * (barWidth + 10);
                    const height = value * 2;
                    
                    ctx.fillStyle = `hsl(${index * 60}, 70%, 60%)`;
                    ctx.fillRect(x, startY - height, barWidth, height);
                    
                    ctx.fillStyle = '#333';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(value, x + barWidth/2, startY - height - 5);
                });
            }

            // 颜色选择器
            initColorPicker() {
                const colorOptions = document.querySelectorAll('.color-option');
                colorOptions.forEach(option => {
                    option.addEventListener('click', () => {
                        colorOptions.forEach(opt => opt.classList.remove('active'));
                        option.classList.add('active');
                        this.currentColor = option.dataset.color;
                    });
                });
            }

            // 画笔大小控制
            initBrushSize() {
                const brushSize = document.getElementById('brushSize');
                const brushSizeDisplay = document.getElementById('brushSizeDisplay');
                
                brushSize.addEventListener('input', () => {
                    this.currentSize = brushSize.value;
                    brushSizeDisplay.textContent = brushSize.value + 'px';
                });
            }

            // 开始绘制
            startDrawing(e) {
                this.isDrawing = true;
                this.draw(e);
            }

            // 绘制
            draw(e) {
                if (!this.isDrawing) return;

                const rect = this.drawingCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                this.drawingCtx.lineWidth = this.currentSize;
                this.drawingCtx.lineCap = 'round';
                this.drawingCtx.strokeStyle = this.currentColor;

                this.drawingCtx.lineTo(x, y);
                this.drawingCtx.stroke();
                this.drawingCtx.beginPath();
                this.drawingCtx.moveTo(x, y);
            }

            // 停止绘制
            stopDrawing() {
                if (this.isDrawing) {
                    this.isDrawing = false;
                    this.drawingCtx.beginPath();
                }
            }

            // 创建粒子
            createParticles() {
                for (let i = 0; i < 50; i++) {
                    this.particles.push({
                        x: Math.random() * this.animationCanvas.width,
                        y: Math.random() * this.animationCanvas.height,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        radius: Math.random() * 3 + 1,
                        color: `hsl(${Math.random() * 360}, 70%, 60%)`
                    });
                }
            }

            // 动画循环
            animate() {
                const ctx = this.animationCtx;
                const canvas = this.animationCanvas;

                ctx.clearRect(0, 0, canvas.width, canvas.height);

                this.particles.forEach(particle => {
                    // 更新位置
                    particle.x += particle.vx;
                    particle.y += particle.vy;

                    // 边界检测
                    if (particle.x < 0 || particle.x > canvas.width) particle.vx *= -1;
                    if (particle.y < 0 || particle.y > canvas.height) particle.vy *= -1;

                    // 绘制粒子
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
                    ctx.fillStyle = particle.color;
                    ctx.fill();
                });

                this.animationId = requestAnimationFrame(() => this.animate());
            }
        }

        // 全局函数
        let canvasDemo;

        document.addEventListener('DOMContentLoaded', () => {
            canvasDemo = new CanvasDemo();
        });

        function drawStaticGraphics() {
            canvasDemo.drawStaticGraphics();
        }

        function clearStaticCanvas() {
            canvasDemo.staticCtx.clearRect(0, 0, canvasDemo.staticCanvas.width, canvasDemo.staticCanvas.height);
        }

        function clearDrawingCanvas() {
            canvasDemo.drawingCtx.clearRect(0, 0, canvasDemo.drawingCanvas.width, canvasDemo.drawingCanvas.height);
        }

        function saveDrawing() {
            const link = document.createElement('a');
            link.download = 'my-drawing.png';
            link.href = canvasDemo.drawingCanvas.toDataURL();
            link.click();
        }

        function drawSamplePattern() {
            const ctx = canvasDemo.drawingCtx;
            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 3;
            
            // 绘制示例图案
            ctx.beginPath();
            for (let i = 0; i < 360; i += 10) {
                const x = 300 + Math.cos(i * Math.PI / 180) * (50 + i / 10);
                const y = 200 + Math.sin(i * Math.PI / 180) * (50 + i / 10);
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
        }

        function startAnimation() {
            if (!canvasDemo.animationId) {
                canvasDemo.animate();
            }
        }

        function stopAnimation() {
            if (canvasDemo.animationId) {
                cancelAnimationFrame(canvasDemo.animationId);
                canvasDemo.animationId = null;
            }
        }

        function resetAnimation() {
            stopAnimation();
            canvasDemo.particles = [];
            canvasDemo.createParticles();
            canvasDemo.animationCtx.clearRect(0, 0, canvasDemo.animationCanvas.width, canvasDemo.animationCanvas.height);
        }
    </script>
</body>
</html>
